[TOC]



1 通用编码规范
============

1.1 命名
----

### 1.1.1 总体风格

**规则1.1 标识符命名使用驼峰风格**

驼峰风格(CamelCase) 大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。 按连接后的首字母是否大写，又分:

大驼峰(UpperCamelCase)、

小驼峰(lowerCamelCase)

**函数，结构体类型，枚举类型，联合体类型：大驼峰**

**变量，函数参数，宏参数，结构体中字段，联合体中成员：小驼峰**

**宏，常量，枚举值，goto 标签：全大写，下划线分割**

注意：常量是指，全局作用域下，const 修饰的基本数据类型、枚举、字符串类型的变量。变量是指除常量定义以外的其他变量，均使用小驼峰风格。

### 1.1.2 文件命名

**建议1.1 文件命名统一采用小写字符**

文件名统一采用全小写字母命名；用下划线”_“分开。

好的命名举例： dhcp\_user\_log.c

### 1.1.3 函数命名

**函数命名统一使用大驼峰风格**

### 1.1.4 变量命名

**变量命名使用小驼峰风格，包括全局变量，局部变量，函数声明或定义中的参数，带括号宏中的参数。**

规则1.2 全局变量应增加 “g\_'”前缀，函数内静态变量命名不需要加特殊前缀

示例：int g\_activeConnectCount;

建议1.2 在能够表达相关含义的前提下，局部变量尽可能简短

### 1.1.5 类型命名

**类型命名采用大驼峰命名风格，类型包括结构体、联合体、枚举类型名。**

示例：

```
struct MsgHead {
    enum MsgType type;
    int msgLen;
    char *msgBuf;
};
union Packet {
    struct SendPacket send;
    struct RecvPacket recv;
};
enum BaseColor {
    RED, // 注意，枚举类型是大驼峰，枚举值应使用宏风格
    GREEN,
    BLUE
};
```

通过 typedef 对结构体、联合体、枚举起别名时，尽量使用匿名类型。

```
typedef struct { // Good: 无须自嵌套，使用匿名结构体
    int a;
    int b;
} MyType; // 结构体别名用大驼峰风格
```

通过 typedef / \#define 对基本类型起别名时，可以遵循C语言本身已有参考实例。

示例：

```
typedef unsigned int uint32; // OK: 不是大驼峰，但符合类似 int 风格
```

### 1.1.6 宏、常量、枚举命名

**宏、枚举值采用全大写，下划线连接的格式。 **

**常量推荐采用全大写，下划线连接风格。**

这里常量如前文定义，是指基本数据类型、枚举、字符串类型的全局 const 变量。

常量举例：

```
const int VERSION = 200; // OK.
const enum Color DEFAULT_COLOR = BLUE; // OK.
const char PATH_SEP = '/'; // OK.
const char * const GREETINGS = "Hello, World!"; // OK.
// 结构体类型，不符合常量定义
const struct MyType g_myData = { ... }; // OK: 用小驼峰
// 注意，枚举类型名用大驼峰，其下面的取值是全大写，下划线相连
enum BaseColor {
    RED,
    GREEN,
    BLUE
};
```
1.2 变量
----

变量在使用时，应始终遵循“职责单一”原则。 按作用域区分，变量可分为全局变量和局部变量。

### 1.2.1 全局变量

**尽量不用或少用全局变量。**

使用全局变量的缺点：破坏函数的独立性和可移植性，使函数对全局变量产生依赖，存在耦合； 降低函数的代码可读性和可维护性。当多个函数读写全局变量时，某一时刻其取值可能不是确定的，对于代码的阅读和维护不利；在并发编程环境中，使用全局变量会破坏函数的可重入性，需要增加额外的同步保护处理才能确保数据安全。如不可避免，对全局变量的读写应集中封装。

**规则1.3 模块间，禁止使用全局变量作接口**

### 1.2.2 局部变量

**规则1.4 严禁使用未经初始化的变量**

**规则1.5 禁止无效、冗余的变量初始化**

例外： 遵从“安全规范”要求，指针变量、表示资源描述符的变量、BOOL变量不作要求。

规则7.4 不允许使用魔鬼数字

魔鬼数字即看不懂、难以理解的数字。

1.3 注释
----

### 1.3.1 文件头注释

**规则1.6 文件头注释必须包含版权许可、功能说明、作者和创建日期**

示例：

```
/*
* Copyright (c) xxx Technologies Co., Ltd. 2020. All rights reserved.
* Description: 文件功能描述
* Author: xw
* Create: 2020-03-30
*/
```

### 1.3.2 函数头注释

**规则1.7 禁止空有格式的函数头注释**

示例：

```
/**
 * ////////////////////////////////abs///////////////////////////////////////
 * @Brief Computes absolute values of vector elements.
 * @param[out]      dst               Pointer to the destination vector.
 * @param[in]        src               Pointer to the source vector for in-place operations.
 * @param[in out]   srcDst             DstPointer to the source and destination vector for in-place operation.
 * @param[in]         len                Number of elements in the vector
 * @retva               HmppResult     HMPP_STS_NO_ERR Indicates no error.
 *                                              HmppStsNullPtrErr Indicates an error when any of the specified pointers is NULL.
 *                                             HMPP_STS_SIZE_ERR Indicates an error when len is less than or equal to 0.
 */
```

### 1.3.3 代码注释

**规则1.8 代码注释放于对应代码的上方或右边 **

**规则1.9 注释符与注释内容间要有1空格；右置注释与前面代码至少1空格**

```
示例：int foo = 100; // 右边的注释
```

上下行注释需要对齐：

```
#define A_CONST 100 // 相关的同类注释，可以考虑上下对齐
#define ANOTHER_CONST 200 // 上下对齐时，与左侧代码保持间隔
```

**规则1.10 不用的代码段直接删除，不要注释掉**

**建议1.3 正式交付的代码不能包含 TODO/TBD/FIXME 注释**

**建议1.4 case语句块结束时如果不加break/return，需要有注释说明(fallthrough)**

**建议1.5 使用流利的英文进行注释**

1.4 排版格式
--------

建议1.6 行宽不超过 120 个字符

规则1.11 使用空格进行缩进，每次缩进4个空格

规则1.12 使用 K&R 缩进风格

规则1.13 函数声明、定义的返回类型和函数名在同一行；函数参数列表换行 时应合理对齐

规则1.14 函数调用参数列表换行时保持参数进行合理对齐

规则1.15 条件语句必须要使用大括号

规则1.16 禁止 if/else/else if 写在同一行

规则1.17 循环语句必须使用大括号

规则1.18 switch 语句的 case/default 要缩进一层

建议1.7 表达式换行要保持换行的一致性，操作符放行末

规则1.18 多个变量定义和赋值语句不允许写在一行

规则1.19 初始化换行时要有缩进，或进行合理对齐

规则1.20 结构体和联合体在按成员初始化时，每个成员初始化单独一行

建议1.8 指针类型"\*"跟随变量名或者类型，不要两边都留有空格或都没有空格

规则1.21 编译预处理的"\#"统一放在行首，嵌套编译预处理语句时，"\#"可以进行缩进

规则1.22 水平空格应该突出关键字和重要信息，避免不必要的留白

建议1.9 减少不必要的空行，保持代码紧凑

2 安全编码规范
============

2.1 基础要求
--------

### 2.1.1 规则：指针变量、表示资源描述符的变量、BOOL变量声明必须赋予初值

变量声明赋予初值，可以避免由于编程人员的疏忽导致的变量未初始化引用。

### 2.1.2 建议：尽量使用const

在变量声明前加const关键字，表示该变量不可被修改，这样就可以利用编译器进行类型检查，将代码的权限降到更低。

### 2.1.3 建议：同一个函数内，局部变量所占用的空间不要过大

程序在运行期间，函数内的局部变量保存在栈中，栈的大小是有限的。如果申请过大的静态数组，可能导致出现运行出错。 建议在申请静态数组的时候，大小不超过0x1000。

2.2 函数 
-----

### 2.2.1 规则：数组作为函数参数时，必须同时将其长度作为函数的参数

通过函数参数传递数组或一块内存进行写操作时，函数参数必须同时传递数组元素个数或所传递的内存块大小，否则函数在使用数组下标或访问内存偏移时，无法判断下标或偏移的合法范围，产生越界访问的漏洞。

例外1： 对于const struct \*类型的数组入参，如果它的长度可以通过特定元素值判断结尾，那么可以不传递结构体数组的长度。

例外2： 对固定长度的数组，如果用数组的头地址作为子函数参数，由于性能原因，可以不用传递其长度。

例外3： C++语言中，编译器会检查对固定长度数组名的引用。如果函数参数不符合引用的数组定义的类型和长度，编译器能够检查出来并报错。因此，对C++中引用固定数组名的参数，不必再额外传递长度参数。

### 2.2.2 规则：不对内容进行修改的指针型参数，定义为const

如果参数是指针型参数，且内容不会被修改，请定义为const类型。

### 2.2.3 建议：字符串或指针作为函数参数时，请检查参数是否为NULL

2.3 整数
----

### 2.3.1 规则：禁止对有符号整数进行位操作符运算

位操作符（～、\>\>、\<\<、&、^、|)应该只用于无符号整型操作数。

（例外：如函数算法本身设计就是对有符号整数进行位运算操作，可以例外）

### 2.3.2 规则：禁止整数与指针间的互相转化

指针的大小随着平台的不同而不同，强行进行整数与指针间的互相转化，降低了程序的兼容性，在转换过程中可能引起指针高位信息的丢失。

### 2.3.3 建议：禁止对指针进行逻辑或位运算（&&、||、!、～、\>\>、\<\<、&、^|）

对指针进行逻辑运算，会导致指针的性质改变，可能产生内存非法访问的问题。

2.4 内存 
-----

### 2.4.1 规则：内存申请前，必须对申请内存大小进行合法性校验

内存申请的大小可能来自于外部数据，必须检查其合法性，防止过多地、非法地申请内存。不能申请0长度的内存。

### 2.4.2 规则：内存分配后必须判断是否成功

### 2.4.3 规则：禁止引用未初始化的内存

malloc分配出来的内存没有被初始化为0，要确保内存被引用前是被初始化的。

### 2.4.4 规则：内存释放之后立即赋予新值

内存释放以后，如果其指针未立即设置为NULL，也未分配一个新的对象，可能会导致这个指针在后续代码中产生双重释放（double-free）的风险，还存在访问已释放内存的危险。消除此类危险指针以及消除众多与内存相关危险的一个为有效地方法就是当指针使用完后将其置新值。如果一个指针释放后能够马上离开作用域，因为它已经不能被再次访问，因此可以无需对其赋予新值。

（例外：如果依据此安全编码规则编码，后经性能测试发现此安全编码部分是影响性能的主要因素，可评审确认后，以性能更优版本为第一选择。）

### 2.4.5 规则：禁止使用realloc()函数

realloc()原型如下：

1.void \*realloc(void \*ptr, size\_t size); 随着参数的不同，其行为也是不同。

1） 当ptr不为NULL，且size不为0时，该函数会重新调整内存大小，并将新的内存指针返回，并保证小的size的内容不变；

2） 参数ptr为NULL，但size不为0，那么行为等同于malloc(size)；3） 参数size为0，则realloc的行为等同于free(ptr)。

由此可见，一个简单的C函数，却被赋予了3种行为，这不是一个设计良好的函数。虽然在编码中提供了一些便利性，但是却极易引发各种bug。

### 2.4.6 规则：禁止使用alloca()函数申请栈上内存

POSIX和C99均未定义alloca()的行为，在有些平台下不支持该函数，使用alloca会降低程序的兼容性和可移植性，该函数在栈帧里申请内存，申请的大小很可能超过栈的边界，影响后续的代码执行。请使用malloc或new，从堆中动态分配内存。

# 3 Clean code规范
Clean code规范如下表<table>
  	<tr>
		<td>Sn</td>
		<td colspan="2" >指标</td>
                 <td>指标定义及价值 </td>
		<td>业界 Good Practice </td>
	<tr>
	 <tr> 

​                             <td rowspan="6">函数</td>

​                               <td rowspan="2">函数行</td> 
	               <td>平均函数代码行 </td>
                               <td>是指一个统计对象总的平均函数代码行，过长的函数往往意味着函数功能不单一，过于复杂。可牵引产品设计良好的目录（子系统）、文件（模块）等 
公式：平均函数代码行=SUM（函数代码行）/总函数个数 </td>

​               <td>平均函数代码行≤30  </td>
	</tr>
              <tr>
		<td>超大函数代码行 </td>
                                <td>是指统计对象代码范围内超过目标值的函数个数。对评估范围内TOPN函数的分析，可帮助业务团队降低函数复杂度，牵引良好设计。 
公式：超大函数个数=SUM(函 数代码行>目标值)   </td>

​                              <td> 函数代码行≤50  </td>
               </tr>
              	 <tr>
                               <td rowspan="2">代码重复</td> 
	               <td>总代码重复率 </td>
                               <td>是指同一交付对象中连续超过一定行数的代码块在其它地方重复出现记为一次重复，合约方代码重复率的计算单元是10行。代码重复导致的“散弹式修改”，给缺陷修复和补丁管理带来极大的困难，不仅降低开发效率，而且容易出错，造成质量和安全隐患。
公式：总代码重复率=重复代码行总数/代码行总数</td>
               <td>≤10% </td>
	</tr>
              <tr>
		<td>源文件代码重复率</td>
                                <td>是指统计对象中源文件的代码重复率。
公式：源文件代码重复率=源文件重复代码行总数/代码行总数</td>
                              <td> NA  </td>
               </tr>
                             	 <tr>
                               <td rowspan="2">圈复杂度</td> 
	                        <td>平均圈复杂度 </td>
                               <td>用来衡量一个程序模块所包含的判定结构的复杂程度，数量上表现为独立路径的条数，即合理地预防错误所需测试的最少路径条数。圈复杂度大的程序，说明其代码可能质量低且难于测试和维护。
公式：平均圈复杂度=SUM（函数圈复杂度）/函数个数。</td>
               <td>平均圈复杂度≤5</td>
	</tr>
              <tr>	          
                                <td>超大圈复杂度</td>
                              <td> 是指评估对象代码范围内圈复杂度超过目标值的函数个数。
公式：超大圈复杂度函数个数=SUM(函数圈复杂度>目标值)  </td>

<td> 超大圈复杂度≤15  </td> </tr>

 <tr>
                               <td rowspan="2">语句</td> 
	               <td colspan="2">冗余代码 </td>
                               <td>是指通过#或者docstring注释掉的代码，以及不可达代码(比如函数内return语句后的代码、不可达的分支代码等等）。冗余代码一直不被测试，在取消注释时存在安全隐患。 </td>
                                <td>“0”</td>
         </tr>
          <tr>
	<td colspan="2">编译告警 </td>
                           <td>编译器编译代码过程中出现的告警。 </td>
                            <td>“0” </td>
           </tr>
</table>

4 禁止开源代码片段引用
====================

4.1 规则：禁止将开源软件部分函数/宏或部分文件拷贝到产品自研代码中使用
-------------------------------------------------------------------

片段引用包括逻辑代码引用（注：函数、变量名不同，逻辑或算法相同的也认为是片段引用）、copyright及其注释信息的引用。

4.2 规则：如需要引用开源软件，需与合约方沟通确认
----------------------------------------------

4.3 参考外部资料（如手册、论文等）写代码时，要先搜索copyright、license字样，尊重知识产权，避免触碰法务风险
------------------------------------------------------------------------------------------------------

4.4 如有参考外部资料、代码，增加注释，说清楚来源以及License等知识产权信息
---------------------------------------------------------------------
